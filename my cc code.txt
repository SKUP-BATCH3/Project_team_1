/*
 * File:   cruise control.c
 * Author: Lenovo
 *
 * Created on September 22, 2022, 10:05 AM
 */


#include <xc.h>
#include "config.h"
#include "init.h"
#define _XTAL_FREQ 20000000
void CC_on_off();
unsigned char receive,receive_1,can_rec;
unsigned char byte=0;
unsigned char state = 0;
unsigned char can_read();
unsigned char can_read_msg[4];
void write_CAN_2(unsigned char ,unsigned);
void write_CAN_1(unsigned char ,unsigned);
 
/*char eeprom1_read(const unsigned char address){
    EEADR=address;
    EECON1bits.EEPGD=0;
    EECON1bits.RD=1;
    byte=EEDATA;
        return byte;
}*/

void write_CAN_1(unsigned char value,unsigned ID)
{

     unsigned char dh,dl;
     dh=(ID>>3) & 0xff;
     dl=(ID<<5) & 0xff;
     
     CANCON=0x08;

     TXB0SIDH=dh;
     TXB0SIDL=dl;
     
     TXB0DLC=0x01;
     
     TXB0D0=value;
     TXB0CON=0x08;
     CANCON=0x08;
     
     LATCbits.LC1 = 1;
}

void write_CAN_2(unsigned char value,unsigned ID)
{

     unsigned char dh,dl;
     dh=(ID>>3) & 0xff;
     dl=(ID<<5) & 0xff;
     
     CANCON=0x08;

     TXB0SIDH=dh;
     TXB0SIDL=dl;
     
     TXB0DLC=0x01;
     
     TXB0D0=value;
     TXB0CON=0x08;
     CANCON=0x08;
     
     LATCbits.LC1 = 1;
}

/*void eeprom1_write(const unsigned char address,unsigned char value)
{
    EEADR = address;
    EEDATA = value;
    EECON1bits.EEPGD = 0;
    EECON1bits.WREN = 1;
    INTCONbits.GIE= 0;
    EECON2 = 0xAA;
    EECON2 = 0x55;   
    EECON1bits.WR=1;
    //INTCONbits.GIE= 1;
      //EECON1bits.WREN = 0;
     //EECON1bits.WR=0;
    PIR2bits.EEIF = 1;
    while(EECON1bits.WR);
        INTCONbits.GIE =0;
}*/


/*void Set_Baud_Rate(int baud)
{
    CANCON=0x80; 
    while(CANSTAT!=0x80);
    if(baud==250)
    {
        BRGCON1=0xC1;
         BRGCON2=0xB1;
         BRGCON3=0x45;
         __delay_ms(10);
         CIOCON=0x20;
         CANCON=0x08;
    }
}*/

void __interrupt() indication()
{
    __delay_ms(20);
    if(INTCONbits.INT0IF == 1)
    {
        if(LATCbits.LC0 == 0)
        {
            LATCbits.LC0 = 1;
            write_CAN_1(0x01,0x64);  
            //__delay_ms(1000);
            INTCONbits.INT0IF = 0;   
        }
        else
        {
                LATCbits.LC0 = 0;
                write_CAN_1(0x00,0x64); 
                INTCONbits.INT0IF = 0;
        }
    }
    else
    {
      ;
    }
 }

 unsigned char can_read()//CAN READ FUNCTION 
{
      CANCON = 0x80;
    
      RXM0SIDL =  RXB0SIDH; //MASK
      RXM0SIDL =  RXB0SIDL;
      
      RXF0SIDL = 0x00;
      RXF0SIDL = 0x00; //FILTER
      
      __delay_ms(1000);
    CANCON = 0x0C;   
    can_read_msg[0] =  RXB0D0;          
    can_read_msg[1] = RXB0DLC;  
    can_read_msg[2] = RXB0SIDL;     
    can_read_msg[3] = RXB0SIDH; 
    RXB0CON = 0X00;     
    CANCON=0x00;
    can_rec =   can_read_msg[0];
    return can_rec;          
}
 
/*void CC_on_off()
{
    
   if(state == 0) 
   {
        eeprom1_write(0x11,0x00);
   }
   else
   {
       ;
   }
     if(state == 1) 
    {
        eeprom1_write(0x11,0x01);
    }   
     else
     {
         ;
     }
}*/

void main(void) 
{
     system_init();
     can_init();
     pheriperal();
     
    TRISCbits.RC0 = 0;
    TRISCbits.RC1 = 0;
    PORTCbits.RC1 = 0;
    LATCbits.LC1 = 0;
    TRISBbits.RB0 = 0;
    
    PORTBbits.RB0 = 1;
     INTCONbits.INT0IF = 0;
    INTCONbits.INT0IE = 1; //enable particular interrupt
    INTCON2bits.INTEDG0 = 1;//rising edge trigger

    while(1)
    {  
        //receive = eeprom1_read(0x11);
        INTCONbits.GIE= 1;
        receive_1 = can_read();
        if(LATCbits.LC0 == 1)
        {
            if (receive_1 == 0x00)
                {
                   // LATCbits.LC1 = 1;
                    __delay_ms(500);
                }
        }
        if(LATCbits.LC0 == 0)
        {
            write_CAN_2( receive_1,0x56);
            __delay_ms(500);
            LATCbits.LC1 = 0;
                
        }
        else
        {
            write_CAN_2(85,0x56);
            __delay_ms(500);
              LATCbits.LC1 = 0;
            
        }
       
   return;
  }
}
      
